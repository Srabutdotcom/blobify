function e(e){if(null===e)return"null";const r=typeof e;return"object"!==r?r:e?.constructor?.name??"Object"}function r(r){const a=[...n(e(r)),...n(r)];return new Blob(a)}function n(e){let n,o=0;switch(typeof e){case"undefined":o=9,n=e;break;case"boolean":case"number":case"string":case"bigint":o=e.toString().length,n=e;break;case"symbol":o=e.description.length,n=e.description;break;case"object":n=null===e?e:function(e){const n=e?.constructor??Object;switch(n){case Blob:case DataView:case ArrayBuffer:case Int8Array:case Uint8Array:case Uint8ClampedArray:case Int16Array:case Uint16Array:case Int32Array:case Uint32Array:case Float32Array:case Float64Array:case BigInt64Array:case BigUint64Array:return e;case String:case Number:case Boolean:return function(e){const{tipe:r,data:n}=e;let a={};if(r==String)for(const e in n)isNaN(e)&&(a[e]=n[e]);else a={...n};return t([n.valueOf(),a])}({data:e,tipe:n});case Array:return t(e);case Object:return a(e);case Map:return function(e){const n=[],a=[...e.entries()];return n.push(r(a)),new Blob(n)}(e);default:return a(e)}}(e),o=null===e?4:n.size??n.length??n.byteLength;break;case"function":{const r=e.toString();n=r.includes("[native code]")?r.replace("[native code]",'return "native code"'):r,o=n.length;break}default:o=e.length??e.size,n=e}return[(""+o).length,o,n]}function a(e){const n=[];for(const a in e)n.push(r(a),r(e[a]));return new Blob(n)}function t(e){const n=[];for(const a of e)n.push(r(a));return new Blob(n)}async function o(e={blob:r,s:0,e:1,type:["text","blob","arrayBuffer"]}){const{blob:r,s:n=0,e:a=1,type:t="text"}=e;if(null==r)return{output:void 0,sliced:void 0,reminder:void 0};const o=r.slice(n,a),c=a===r.size?void 0:r.slice(a);return{output:await o[t](),sliced:o,reminder:c}}async function c(e){const{output:r,reminder:n}=await o({blob:e.blob}),{output:a,reminder:t}=await o({blob:n,e:+r});return await o({blob:t,e:+a,type:e.type})}async function i(e){const{output:r,reminder:n}=await c({blob:e}),{output:a,reminder:t,sliced:o}=await c({blob:n,type:u(r)});switch(r){case"null":return{blob:t,value:null};case"undefined":return{blob:t,value:void 0};case"boolean":return{blob:t,value:"true"===a};case"string":case"ArrayBuffer":default:return{blob:t,value:a};case"number":return{blob:t,value:+a};case"bigint":return{blob:t,value:BigInt(a)};case"symbol":return{blob:t,value:Symbol(a)};case"String":case"Number":case"Boolean":return await async function(e){const r={Boolean:e=>new Boolean(e),Number:e=>new Number(e),String:e=>new String(e)},{type:n}=e,{value:a,blob:t}=await s(e),o=r[n](a[0]);for(const e in a[1])o[e]=a[1][e];return{blob:t,value:o}}({blob:o,reminder:t,type:r});case"PublicKeyCredential":case"AuthenticatorAssertionResponse":case"Object":return await async function(e={}){if(void 0===e.blob)return{blob:void 0,value:{}};let r={},n="isNotDefinedYet",a=e.blob;do{const{value:e,blob:t}=await i(a);if(a=t,"isNotDefinedYet"!==n){const a={};a[n]=e,r={...r,...a},n="isNotDefinedYet"}else n=e}while(a&&a.size>0);return{blob:e.reminder,value:r}}({blob:o,reminder:t});case"Array":return await s({blob:o,reminder:t});case"Blob":return{blob:t,value:t};case"Int8Array":return{blob:t,value:new Int8Array(a)};case"Uint8Array":return{blob:t,value:new Uint8Array(a)};case"Uint8ClampedArray":return{blob:t,value:new Uint8ClampedArray(a)};case"Int16Array":return{blob:t,value:new Int16Array(a)};case"Uint16Array":return{blob:t,value:new Uint16Array(a)};case"Int32Array":return{blob:t,value:new Int32Array(a)};case"Uint32Array":return{blob:t,value:new Uint32Array(a)};case"Float32Array":return{blob:t,value:new Float32Array(a)};case"Float64Array":return{blob:t,value:new Float64Array(a)};case"BigInt64Array":return{blob:t,value:new BigInt64Array(a)};case"BigUint64Array":return{blob:t,value:new BigUint64Array(a)};case"DataView":return{blob:t,value:new DataView(a)};case"function":return{blob:t,value:Function("return "+a)()};case"Map":return await async function(e){const{value:r,blob:n}=await s(e);return{blob:e.reminder,value:new Map(...r)}}({blob:o,reminder:t})}}function u(e){switch(e){case"null":case"undefined":case"boolean":case"string":case"number":case"bigint":case"symbol":case"Object":case"Array":case"Blob":default:return"text";case"ArrayBuffer":case"Int8Array":case"Uint8Array":case"Uint8ClampedArray":case"Int16Array":case"Uint16Array":case"Int32Array":case"Uint32Array":case"Float32Array":case"Float64Array":case"BigInt64Array":case"BigUint64Array":return"arrayBuffer"}}async function s(e){const r=[];let n=e.blob;do{const{value:e,blob:a}=await i(n);n=a,r.push(e)}while(n&&n.size>0);return{blob:e.reminder,value:r}}async function l(e){const{value:r}=await i(e);return r}async function b(e,n){Deno.writeFileSync(e,new Uint8Array(await r(n).arrayBuffer()))}async function y(e){return await l(new Blob([Deno.readFileSync(e)]))}new TextDecoder,new TextEncoder;export{r as blobify,i as getValueBasedOnType,l as parseBlob,y as readBlob,b as writeBlob};
