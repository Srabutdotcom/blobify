function e(e){if(null===e)return"null";const r=typeof e;return"object"!==r?r:e?.constructor?.name??"Object"}function r(r){const t=[...n(e(r)),...n(r)];return new Blob(t)}function n(e){let n,o=0;switch(typeof e){case"undefined":o=9,n=e;break;case"boolean":case"number":case"string":case"bigint":o=e.toString().length,n=e;break;case"symbol":o=e.description.length,n=e.description;break;case"object":n=null===e?e:function(e){const n=e?.constructor??Object;switch(n){case Blob:case DataView:case ArrayBuffer:case Int8Array:case Uint8Array:case Uint8ClampedArray:case Int16Array:case Uint16Array:case Int32Array:case Uint32Array:case Float32Array:case Float64Array:case BigInt64Array:case BigUint64Array:return e;case String:case Number:case Boolean:return function(e){const{tipe:r,data:n}=e;let t={};if(r==String)for(const e in n)isNaN(e)&&(t[e]=n[e]);else t={...n};return a([n.valueOf(),t])}({data:e,tipe:n});case Array:return a(e);case Object:return t(e);case Map:return function(e){const n=[],t=[...e.entries()];return n.push(r(t)),new Blob(n)}(e);default:return t(e)}}(e),o=null===e?4:n.size??n.length??n.byteLength;break;case"function":{const r=e.toString();n=r.includes("[native code]")?r.replace("[native code]",'return "native code"'):r,o=n.length;break}default:o=e.length??e.size,n=e}return[(""+o).length,o,n]}function t(e){const n=[];for(const t in e)n.push(r(t),r(e[t]));return new Blob(n)}function a(e){const n=[];for(const t of e)n.push(r(t));return new Blob(n)}async function o(e={blob:r,s:0,e:1,type:["text","blob","arrayBuffer"]}){const{blob:r,s:n=0,e:t=1,type:a="text"}=e;if(null==r)return{output:void 0,sliced:void 0,reminder:void 0};const o=r.slice(n,t),c=t===r.size?void 0:r.slice(t);return{output:await o[a](),sliced:o,reminder:c}}async function c(e){const{output:r,reminder:n}=await o({blob:e.blob}),{output:t,reminder:a}=await o({blob:n,e:+r});return await o({blob:a,e:+t,type:e.type})}async function s(e){const{output:r,reminder:n}=await c({blob:e}),{output:t,reminder:a,sliced:o}=await c({blob:n,type:u(r)});switch(r){case"null":return{blob:a,value:null};case"undefined":return{blob:a,value:void 0};case"boolean":return{blob:a,value:"true"===t};case"string":case"ArrayBuffer":default:return{blob:a,value:t};case"number":return{blob:a,value:+t};case"bigint":return{blob:a,value:BigInt(t)};case"symbol":return{blob:a,value:Symbol(t)};case"String":case"Number":case"Boolean":return await async function(e){const r={Boolean:e=>new Boolean(e),Number:e=>new Number(e),String:e=>new String(e)},{type:n}=e,{value:t,blob:a}=await i(e),o=r[n](t[0]);for(const e in t[1])o[e]=t[1][e];return{blob:a,value:o}}({blob:o,reminder:a,type:r});case"PublicKeyCredential":case"AuthenticatorAssertionResponse":case"Object":return await async function(e={}){if(void 0===e.blob)return{blob:void 0,value:{}};let r={},n="isNotDefinedYet",t=e.blob;do{const{value:e,blob:a}=await s(t);if(t=a,"isNotDefinedYet"!==n){const t={};t[n]=e,r={...r,...t},n="isNotDefinedYet"}else n=e}while(t&&t.size>0);return{blob:e.reminder,value:r}}({blob:o,reminder:a});case"Array":return await i({blob:o,reminder:a});case"Blob":return{blob:a,value:a};case"Int8Array":return{blob:a,value:new Int8Array(t)};case"Uint8Array":return{blob:a,value:new Uint8Array(t)};case"Uint8ClampedArray":return{blob:a,value:new Uint8ClampedArray(t)};case"Int16Array":return{blob:a,value:new Int16Array(t)};case"Uint16Array":return{blob:a,value:new Uint16Array(t)};case"Int32Array":return{blob:a,value:new Int32Array(t)};case"Uint32Array":return{blob:a,value:new Uint32Array(t)};case"Float32Array":return{blob:a,value:new Float32Array(t)};case"Float64Array":return{blob:a,value:new Float64Array(t)};case"BigInt64Array":return{blob:a,value:new BigInt64Array(t)};case"BigUint64Array":return{blob:a,value:new BigUint64Array(t)};case"DataView":return{blob:a,value:new DataView(t)};case"function":return{blob:a,value:Function("return "+t)()};case"Map":return await async function(e){const{value:r,blob:n}=await i(e);return{blob:e.reminder,value:new Map(...r)}}({blob:o,reminder:a})}}function u(e){switch(e){case"null":case"undefined":case"boolean":case"string":case"number":case"bigint":case"symbol":case"Object":case"Array":case"Blob":default:return"text";case"ArrayBuffer":case"Int8Array":case"Uint8Array":case"Uint8ClampedArray":case"Int16Array":case"Uint16Array":case"Int32Array":case"Uint32Array":case"Float32Array":case"Float64Array":case"BigInt64Array":case"BigUint64Array":return"arrayBuffer"}}async function i(e){const r=[];let n=e.blob;do{const{value:e,blob:t}=await s(n);n=t,r.push(e)}while(n&&n.size>0);return{blob:e.reminder,value:r}}async function l(e){const{value:r}=await s(e);return r}new TextDecoder,new TextEncoder;export{r as blobify,s as getValueBasedOnType,l as parseBlob};
